<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Motifs: shapes and sampling · RecurrenceMicrostatesAnalysis.jl</title><meta name="title" content="Motifs: shapes and sampling · RecurrenceMicrostatesAnalysis.jl"/><meta property="og:title" content="Motifs: shapes and sampling · RecurrenceMicrostatesAnalysis.jl"/><meta property="twitter:title" content="Motifs: shapes and sampling · RecurrenceMicrostatesAnalysis.jl"/><meta name="description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="og:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="twitter:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RecurrenceMicrostatesAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Welcome</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><a class="tocitem" href="../theory/">Theoretical Overview</a></li><li><a class="tocitem" href="../distributions/">Distributions</a></li><li><a class="tocitem" href="../rqa/">RQA</a></li><li><a class="tocitem" href="../utils/">Utils</a></li><li><a class="tocitem" href="../performance/">Performance Tips</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../api/">Public API</a></li><li class="is-active"><a class="tocitem" href>Motifs: shapes and sampling</a><ul class="internal"><li><a class="tocitem" href="#Shapes"><span>Shapes</span></a></li><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li></ul></li><li><a class="tocitem" href="../recurrence/">Recurrence functions</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../bib/">Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Motifs: shapes and sampling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Motifs: shapes and sampling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DynamicsUFPR/RecurrenceMicrostatesAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/DynamicsUFPR/RecurrenceMicrostatesAnalysis.jl/blob/master/docs/src/motifs.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Motifs:-shapes-and-sampling"><a class="docs-heading-anchor" href="#Motifs:-shapes-and-sampling">Motifs: shapes and sampling</a><a id="Motifs:-shapes-and-sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Motifs:-shapes-and-sampling" title="Permalink"></a></h1><p>The library supports different motif shapes and sampling modes. Here, we present a brief explanation of how these mechanisms work and how you can create your own shape or sampling mode.</p><h2 id="Shapes"><a class="docs-heading-anchor" href="#Shapes">Shapes</a><a id="Shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Shapes" title="Permalink"></a></h2><p>By default, the library includes five predefined motif shapes: <code>:square</code>, <code>:triangle</code>, <code>:pair</code>, <code>:line</code>, and <code>:diagonal</code>. These shapes are defined in the file <code>src/rma/index.jl</code>, and they determine how a motif is drawn by the library and how it is converted to a decimal value used as an index. Therefore, when constructing a motif shape, it is important to consider how it will be converted into a decimal value.</p><p>For example, a square motif can be converted into a decimal value using the following equation (without spatial generalization).</p><p class="math-container">\[I = \sum_{r = 0}^{n - 1}\sum_{c = 0}^{n - 1} 2^{rn+c}~\mathbf{R}_{i+r, j+c},\]</p><p>where <span>$2^{rn+c}$</span> is responsible for associating each position of the motif with a power of 2, converting the binary structure into a decimal value. A Julia&#39;s function to compute it can be written as:</p><pre><code class="language-julia hljs">function compute_index_square(x::AbstractArray, y::AbstractArray, parameters, structure::AbstractVector{Int}, func::F, dim::AbstractVector{Int}, fixed::Vector{Int}, itr::Vector{Int}, metric) where {F}

    ##      Let a variable to store the index.
    I = 0

    ##      Copy the values of the fixed indeces to the vector of iterative indeces.
    copy!(itr, fixed)       ##  We do it to avoid memory allocations =D

    ##      Iterate to compute the index.
    for r in 0:(structure[1] - 1)
        for c in 0:(structure[2] - 1)
            ##      Change the iterator.
            itr[1] = fixed[1] + r
            itr[2] = fixed[2] + c

            ##      Calculate the recurrence between two positions.
            if @inline func(x, y, parameters, itr, metric, dim)
                index += 2^((r * structure[1]) + c)
            end
        end
    end

    return I + 1 ##     It is necessary for Julia indexing! i = I + 1
end</code></pre><p>Knowing an algebraic expression to convert a motif into a decimal value is not strictly necessary, but it is recommended — especially considering the importance of understanding how this process will work for any value of <span>$n$</span> (if applicable). For example, consider a motif with an X-shape (for <span>$n = 3$</span>):</p><p class="math-container">\[\begin{pmatrix}
\xi_1   &amp;       &amp;  \xi_2    \\
        &amp; \xi_3 &amp;           \\
\xi_4   &amp;       &amp;  \xi_5
\end{pmatrix}\]</p><p>It is easy to convert this shape into an index using something like:</p><pre><code class="language-julia hljs">function compute_index_x(x::AbstractArray, y::AbstractArray, parameters, func::F, dim::AbstractVector{Int}, fixed::Vector{Int}, itr::Vector{Int}, metric) where {F}

    ##      Let a variable to store the index.
    I = 0

    ##      Copy the values of the fixed indeces to the vector of iterative indeces.
    copy!(itr, fixed)       ##  We do it to avoid memory allocations =D

    ##  1. \xi_1
    if @inline func(x, y, parameters, itr, metric, dim)
        I += 1
    end

    ##  2. \xi_2
    itr[2] = fixed[2] + 2
    if @inline func(x, y, parameters, itr, metric, dim)
        I += 2
    end

    ##  3. \xi_3
    itr[1] = fixed[1] + 1
    itr[2] = fixed[2] + 1
    if @inline func(x, y, parameters, itr, metric, dim)
        I += 4
    end

    ##  4. \xi_4
    itr[1] = fixed[1] + 2
    itr[2] = fixed[2]
    if @inline func(x, y, parameters, itr, metric, dim)
        I += 8
    end

    ##  5. \xi_5
    itr[2] = fixed[2] + 2
    if @inline func(x, y, parameters, itr, metric, dim)
        I += 16
    end

    return I + 1 ##     It is necessary for Julia indexing! i = I + 1
end</code></pre><p>But it is also clear that this code is not scalable, as it relies on a fixed structure. Transforming this into a scalable version that can handle any motif structure is one of the key computational challenges in the process of defining a new motif shape.</p><p>The application of a shape is associated with a sampling mode, so it is necessary to create a sampling function for each defined shape. This is because the sampling mode determines how the <code>fixed</code> parameter is set.</p><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><p>The sampling defines how each motif will be extracted from an RP, without computing the full RP explicitly. The library includes five predefined sampling modes: <code>:full</code>, <code>:random</code>, <code>:triangleup</code>, <code>:columnwise</code> and <code>:columnwise_full</code>. These modes are defined in the folder <code>src/rma/histograms/</code>, being called by the function <code>distribution(...)</code>.</p><p>The difficulty of creating a sampling function is proportional to the complexity of your problem. For example, if you are sampling motifs randomly from the RP, the sampling function is simple. However, if the motifs need to be extracted from a specific structure, the difficulty increases.</p><p>The sampling code for a <code>:random</code> sampling using square motifs is</p><pre><code class="language-julia hljs">function vect_square_random(x::AbstractArray, y::AbstractArray, parameters, structure::AbstractVector{Int},
    space_size::AbstractVector{Int}, func::F, dim::AbstractVector{Int}, hv::Int, samples::Int, metric) where {F}

    ##
    ##      Alloc memory for the histogram and the index list.
    hg = zeros(Int, 2^hv)   ##  Our histogram!
    fixed = ones(Int, length(space_size))
    itr = zeros(Int, length(space_size))

    ##
    ##      Compute the power vector.
    p_vect = zeros(Int, hv)
    for i in 1:hv
        p_vect[i] = 2^(i - 1)
    end

    ##
    ##      Get the samples and compute the histogram.
    @inbounds for _ in 1:samples
        ##
        ##      Take a random index.
        for s in eachindex(space_size)
            fixed[s] = rand(1:space_size[s])
        end

        ##
        ##      Compute the index and register the motif.
        p = @fastmath compute_index_square(x, y, parameters, structure, func, dim, fixed, itr, p_vect, metric)
        hg[p] += 1
    end

    ##
    ##      Return the histogram.
    return hg
end</code></pre><p>In this code, we compute the power vector (<code>p_vect</code>) before calling the <code>compute_index_square</code> function, so it is not necessary to calculate powers of 2 inside the loop. Moreover, we allocate memory for the iterator <code>itr</code> and the fixed indices <code>fixed</code> outside the loop to avoid unnecessary calls to the garbage collector. The <code>for</code>...</p><pre><code class="language-julia hljs">for s in eachindex(space_size)
    fixed[s] = rand(1:space_size[s])
end</code></pre><p>... retrieves an index set <span>$(i,j)$</span> to define the first recurrence <span>$R_{ij}$</span>, , from which a motif is constructed using the shape function <code>compute_index_square</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« Public API</a><a class="docs-footer-nextpage" href="../recurrence/">Recurrence functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Tuesday 24 June 2025 15:56">Tuesday 24 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
